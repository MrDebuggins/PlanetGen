#version 430

layout (quads, equal_spacing, ccw) in;

uniform mat4 view;            // view matrix
uniform mat4 model;           // model matrix
uniform mat4 projection;      // projection matrix

uniform vec3 cameraPos_m;      // camera position in meters
uniform vec3 cameraPos_M;      // camera position in mega meters

uniform vec3 objPos;		  // object position in meters
uniform float radius;         // planet radius
uniform float[5] periods;	  // layers resoulutions
uniform float[5] amps;	      // layers amplitudes
uniform float maxAlt;		  // max altitude
uniform float thresh;		  // threshold
uniform int noiseMode;		  // noise mode

out vec3 color;
out vec3 normal;
out vec3 fragPos;
out vec3 cameraPos;
out int spec;

vec3 color1 = vec3(0.2588, 0.1254, 0.0039);
vec3 color2 = vec3(0.0627, 0.4588, 0.0039);
vec3 color3 = vec3(0.0041, 0.1568, 0.3411);

float coefs[] = {1.0, 1.0, 1.0, 1.0, 1.0};

#define PI 3.1415926535897932384626433832795

float interpolate(float a0, float a1, float w)
{
	//return (a1 - a0) * w + a0;
	return (a1 - a0) * (3.0 - w * 2.0) * w * w + a0;
	//return (a1 - a0) * ((w * (w * 6.0 - 15.0) + 10.0) * w * w * w) + a0;
}

// https://www.shadertoy.com/view/4djSRW
///  3 out, 3 in...
vec3 hash33(vec3 p3)
{
	p3 = fract(p3 * vec3(.10310973, .10301031, .09731030));
    p3 += dot(p3, p3.yxz+33.33);
    return fract((p3.xxy + p3.yxx)*p3.zyx);

}

float dotGridGradient3(float ix, float iy, float iz, float x, float y, float z)
{
	vec3 gradient = hash33(vec3(ix, iy, iz));	
	vec3 dist = vec3(x, y, z) - vec3(ix, iy, iz);
	return dot(dist, gradient);
}

float ridgeTransform(float h)
{
	return abs(h - 0.5f) * 2.0f;
}

float perlinAux(float x, float y, float z, float res, float ampl)
{
	float x0 = int(res * floor(x / res));
	float x1 = x0 + res;
	float y0 = int(res * floor(y / res));
	float y1 = y0 + res;
	float z0 = int(res * floor(z / res));
	float z1 = z0 + res;

	float sx = (x - float(x0)) / res;
	float sy = (y - float(y0)) / res;
	float sz = (z - float(z0)) / res;

	float n0, n1, iz0, iz1, iz2, iz3, ix0, ix1, value;

	n0 = dotGridGradient3(x0, y0, z0, x, y, z);
	n1 = dotGridGradient3(x0, y0, z1, x, y, z);
	iz0 = interpolate(n0, n1, sz);

	n0 = dotGridGradient3(x1, y0, z0, x, y, z);
	n1 = dotGridGradient3(x1, y0, z1, x, y, z);
	iz1 = interpolate(n0, n1, sz);

	n0 = dotGridGradient3(x0, y1, z0, x, y, z);
	n1 = dotGridGradient3(x0, y1, z1, x, y, z);
	iz2 = interpolate(n0, n1, sz);

	n0 = dotGridGradient3(x1, y1, z0, x, y, z);
	n1 = dotGridGradient3(x1, y1, z1, x, y, z);
	iz3 = interpolate(n0, n1, sz);

	ix0 = interpolate(iz0, iz1, sx);
	ix1 = interpolate(iz2, iz3, sx);

	value = interpolate(ix0, ix1, sy);
	value = ((value / res) * 3.0 + 1.1);

	return value * ampl;
}

float perlin3(float x, float y, float z, float res, float ampl)
{
	if(noiseMode == 3)
	{
		float tmp = perlinAux(x, y, z, 20000, 2000);
		x += tmp;
		y += tmp;
		z += tmp;
	}

	float x0 = int(res * floor(x / res));
	float x1 = x0 + res;
	float y0 = int(res * floor(y / res));
	float y1 = y0 + res;
	float z0 = int(res * floor(z / res));
	float z1 = z0 + res;

	float sx = (x - float(x0)) / res;
	float sy = (y - float(y0)) / res;
	float sz = (z - float(z0)) / res;

	float n0, n1, iz0, iz1, iz2, iz3, ix0, ix1, value;

	n0 = dotGridGradient3(x0, y0, z0, x, y, z);
	n1 = dotGridGradient3(x0, y0, z1, x, y, z);
	iz0 = interpolate(n0, n1, sz);

	n0 = dotGridGradient3(x1, y0, z0, x, y, z);
	n1 = dotGridGradient3(x1, y0, z1, x, y, z);
	iz1 = interpolate(n0, n1, sz);

	n0 = dotGridGradient3(x0, y1, z0, x, y, z);
	n1 = dotGridGradient3(x0, y1, z1, x, y, z);
	iz2 = interpolate(n0, n1, sz);

	n0 = dotGridGradient3(x1, y1, z0, x, y, z);
	n1 = dotGridGradient3(x1, y1, z1, x, y, z);
	iz3 = interpolate(n0, n1, sz);

	ix0 = interpolate(iz0, iz1, sx);
	ix1 = interpolate(iz2, iz3, sx);

	value = interpolate(ix0, ix1, sy);
	value = ((value / res) * 3.0 + 1.1);

	if(noiseMode == 0)
		value = value;
	if(noiseMode == 1)
		value = ridgeTransform(value);
	if(noiseMode == 2)
		value = sin(PI*(value - 1/2)/2 + 1/2) * 1.2;

	return value * ampl;
}

float perlin5Layers(vec3 vertex)
{
	float perlin = perlin3(vertex.x, vertex.y, vertex.z, periods[0], amps[0] * coefs[0]);
	perlin += perlin3(vertex.x, vertex.y, vertex.z, periods[1], amps[1] * coefs[1]);
	perlin += perlin3(vertex.x, vertex.y, vertex.z, periods[2], amps[2] * coefs[2]);
	perlin += perlin3(vertex.x, vertex.y, vertex.z, periods[3], amps[3] * coefs[3]);
	perlin += perlin3(vertex.x, vertex.y, vertex.z, periods[4], amps[4] * coefs[4]);

	if(perlin < (maxAlt * thresh))
		return maxAlt * thresh;
	
	return perlin;
}

void calcColor(float perlin)
{
	if(perlin <= (thresh * maxAlt))
	{
		color = color3;
		spec = 1;
	}
	else
	{
		float a = perlin / maxAlt;
		vec3 b = vec3(a+0.3, a-0.3, a);
		color = color1 * a + (1 - a) * color2;
	}

	color *= 2.5;
}

vec3 calcVertexNormal(vec4 p00, vec4 p01, vec4 p10, vec4 p11, float u, float v)
{
	float u0 = u + 0.0625;
	float u1 = u - 0.0625;
	float v0 = v - 0.0625;

	// sample point 0 (u0, v)
	vec4 p0 = (p01 - p00) * u0 + p00;
    vec4 p1 = (p11 - p10) * u0 + p10;
    vec3 s0Cube = ((p1 - p0) * v + p0).xyz;
	vec3 s0 = normalize(s0Cube.xyz);
	vec3 s0Sph = s0 * radius;
	s0 = (1 + perlin5Layers(s0Sph)) * s0 + objPos;

	// sample point 1 (u1, v)
	p0 = (p01 - p00) * u1 + p00;
    p1 = (p11 - p10) * u1 + p10;
    vec3 s1Cube = ((p1 - p0) * v + p0).xyz;
	vec3 s1 = normalize(s1Cube.xyz);
	vec3 s1Sph = s1 * radius;
	s1 = (1 + perlin5Layers(s1Sph)) * s1 + objPos;

	//sample point 2 (u, v0)
	p0 = (p01 - p00) * u + p00;
    p1 = (p11 - p10) * u + p10;
    vec3 s2Cube = ((p1 - p0) * v0 + p0).xyz;
	vec3 s2 = normalize(s2Cube.xyz);
	vec3 s2Sph = s2 * radius;
	s2 = (1 + perlin5Layers(s2Sph)) * s2 + objPos;

	vec3 A = s1 - s0;
	vec3 B = s2 - s1;

	return normalize(cross(A, B));
}

vec3 calcNormal(vec3 p)
{
	dvec3 p1 = normalize(dvec3(p) + dvec3(160, 160, 0));
	dvec3 p2 = normalize(dvec3(p) + dvec3(0, 160, 160));
	p1 = p1 * double(radius) + dvec3(perlin5Layers(vec3(p1) * radius)) * p1;
	p2 = p2 * double(radius) + dvec3(perlin5Layers(vec3(p2) * radius)) * p2;

	return vec3(normalize(cross(p1 - p2, p - p1)));
}

vec3 calcPatchNormal(vec3 p00, vec3 p01, vec3 p10)
{
	p00 = normalize(p00);
	p01 = normalize(p01);
	p10 = normalize(p10);
	vec3 p00s = p00 * radius;
	vec3 p01s = p01 * radius;
	vec3 p10s = p10 * radius;
	p00 = p00 * (1 + perlin5Layers(p00s)) + objPos;
	p01 = p01 * (1 + perlin5Layers(p01s)) + objPos;
	p10 = p10 * (1 + perlin5Layers(p10s)) + objPos;

	vec3 a = p01 - p00;
	vec3 b = p10 - p01;

	return normalize(cross(a, b));
}

void main()
{
    // get patch coordinate
    float u = gl_TessCoord.x;
    float v = gl_TessCoord.y;

    // ----------------------------------------------------------------------
    // retrieve control point position coordinates
    vec4 p00 = gl_in[0].gl_Position;
    vec4 p01 = gl_in[1].gl_Position;
	vec4 p10 = gl_in[2].gl_Position;
	vec4 p11 = gl_in[3].gl_Position;

    // bilinearly interpolate position coordinate across patch
    vec4 p0 = (p01 - p00) * u + p00;
    vec4 p1 = (p11 - p10) * u + p10;
    vec4 p = (p1 - p0) * v + p0;

	// ----------------------------------------------------------------------
	// compute final position in double (there is no significant difference in performance for such small portion of operations) ~500 fps rtx 3060 worst case
	
	// spherified position
	dvec3 normalized = normalize(dvec3(p.xyz));
	dvec3 spherified = normalized * double(radius);
	//vec3 normalized = normalize(p.xyz);
	//vec3 spherified = normalized * radius;

	// vertex normal
	normal =  calcVertexNormal(p00, p01, p10, p11, u, v);




	//float an = PI - acos(dot(normal, vec3(normalized)));
	//float tst = an / PI / 2;
	//coefs[0] *= tst;
	//coefs[1] *= tst;
	//coefs[2] *= tst;
	//coefs[3] *= tst;
	//coefs[4] *= tst;





	// perlin noise
	float perlin = perlin5Layers(vec3(spherified));
	vec3 noise = vec3(normalized) * perlin;

	// final position
	p.xyz = vec3((spherified + dvec3(objPos - cameraPos_M)) - dvec3(cameraPos_m)) + noise;
	//p.xyz = vec3((spherified + objPos - cameraPos_M) - cameraPos_m) + noise;

	// fragment shader data
	calcColor(perlin);
	//color = vec3(tst, 0, 0);
	fragPos = vec3(spherified) + objPos + noise;
	cameraPos = cameraPos_M + cameraPos_m;
	normal = 0.5 * normal + 0.5 * vec3(normalized);

    // ----------------------------------------------------------------------
    // output patch point position in clip space
    gl_Position = projection * view * model * p;

	// z fighting 
	gl_Position.z = 2.0*log(gl_Position.w*1 + 1)/log(10000000000.0 * 1.0 + 1) - 1;
	gl_Position.z *= gl_Position.w;
}