#version 430

layout (vertices=4) out;

uniform vec3 cameraPos;      // camera position
uniform vec3 objPos;		  // object position
uniform float radius;         // planet radius

out vec2 uvsCoord[];

void main()
{
    float PI = 3.1415927410125732421875f;

    // ----------------------------------------------------------------------
    // pass attributes through
    gl_out[gl_InvocationID].gl_Position = gl_in[gl_InvocationID].gl_Position;

    // ----------------------------------------------------------------------
    // invocation zero controls tessellation levels for the entire patch
    if (gl_InvocationID == 0)
    {
        vec3 p0 = normalize(gl_in[0].gl_Position.xyz) * radius;
        vec3 p1 = normalize(gl_in[1].gl_Position.xyz) * radius;
        vec3 p2 = normalize(gl_in[2].gl_Position.xyz) * radius;
        vec3 p3 = normalize(gl_in[3].gl_Position.xyz) * radius;

        // patch center
        vec3 c = vec3((p0.x+p1.x+p2.x+p3.x)/4, (p0.y+p1.y+p2.y+p3.y)/4, (p0.z+p1.z+p2.z+p3.z)/4);

        // patch width
        float w = distance(p0, p1);

        // angle between camera vector and patch center vector
        float a = acos(dot(normalize(cameraPos - objPos), normalize(c)));

        // angle between patch-camera vector and patch-origin vector
        float b = PI - acos(dot(normalize(cameraPos - objPos - c), normalize(c)));
        
        uint lvl;
        if(b < (PI / 2.0f))
        {
            lvl = 1;
            if(w > (radius / 2))
                lvl = uint(w / (radius / 64.0f));
        }
        else
        {
            lvl = 64;
        }

        gl_TessLevelOuter[0] = 64;
        gl_TessLevelOuter[1] = 64;
        gl_TessLevelOuter[2] = 64;
        gl_TessLevelOuter[3] = 64;

        gl_TessLevelInner[0] = lvl;
        gl_TessLevelInner[1] = lvl;

    }
}